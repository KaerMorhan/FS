import fs from 'node:fs'
import path from 'node:path'
import { exec } from 'node:child_process'
import orderBy from 'lodash.orderby'

/*
 * Shared header to include in written .mjs files
 */
export const header = `/*
 * This file was auto-generated by the prebuild script
 * Any changes you make to it will be lost on the next (pre)build.
 */
`

/*
 * Strips quptes from the start/end of a string
 */
const stripQuotes = (str) => {
  str = str.trim()
  if (str.slice(0, 1) === '"') str = str.slice(1)
  if (str.slice(-1) === '"') str = str.slice(0, -1)

  return str.trim()
}

/*
 * This is the fast and low-tech way to some frontmatter from all files in a folder
 */
const loadFolderFrontmatter = async (key, site, language, folder, transform = false) => {
  const prefix = site === 'org' ? `${folder}/` : ''
  /*
   * Figure out what directory to spawn the child process in
   */
  const cwd = await path.resolve(process.cwd(), '..', '..', 'markdown', site, folder)
  /*
   * When going through a small number of files in a flat directory (eg. blog posts) a
   * recursive grep through all files is faster.
   * But the biggest task is combing through all the org documentation and for this
   * it's much faster to first run find to limit the number of files to open
   */
  const cmd = `find ${cwd} -type f -name "${language}.md" -exec grep "^${key}:" -ism 1 {} +`
  const grep = exec(cmd, { cwd }, (error, stdout, stderr) => {
    if (error) {
      console.error(`exec error: ${error} - ${stderr}`)
      return
    }

    return stdout
  })

  /*
   * Stdout is buffered, so we need to gather all of it
   */
  let stdout = ''
  for await (const data of grep.stdout) stdout += data

  /*
   * Turn all matches into an array
   */
  const matches = stdout.split('\n')

  /*
   * Turns matches into structured data
   */
  const pages = {}
  for (let match of matches) {
    /*
     * Trim some of the irrelevant path info prior to splitting on '.md:{key}:'
     */
    const chunks = match
      .split(`markdown/${site}/${site === 'dev' ? '' : folder + '/'}`)
      .pop()
      .split(`.md:${key}:`)
    if (chunks.length === 2 && chunks[0].length > 1) {
      /*
       * Add page to our object with slug as key and title as value
       */
      let slug = prefix + chunks[0].slice(0, -3)
      if (slug === prefix) slug = slug.slice(0, -1)
      pages[slug] = transform
        ? transform(stripQuotes(chunks[1]), slug, language)
        : stripQuotes(chunks[1])
    }
  }

  return pages
}

/*
 * Merges in order key on those slugs that have it set
 */
const mergeOrder = (titles, order, withSlug = false) => {
  const pages = {}
  for (const [slug, t] of Object.entries(titles)) {
    pages[slug] = { t }
    if (order[slug]) pages[slug].o = order[slug]
    if (withSlug) pages[slug].s = slug
  }

  return pages
}

/*
 * Fixes the date format to be yyyymmdd
 */
const formatDate = (date, slug, lang) => {
  date = date.split('-')
  if (date.length === 1) date = date[0].split('.')
  if (date.length === 1) console.log(`Could not format date ${date} from ${slug} (${lang})`)
  else {
    if (date[0].length === 4) return date.join('')
    else return date.reverse().join('')
  }
}

/*
 * Loads all docs files, titles and order
 */
const loadDocs = async (store) => {
  const folder = store.site === 'org' ? 'docs' : '.'
  const titles = await loadFolderFrontmatter('title', store.site, store.language, folder)
  // Order is the same for all languages, so only grab EN files
  const order = await loadFolderFrontmatter('order', store.site, store.language, folder, false)

  return mergeOrder(titles, order)
}

/*
 * Loads all blog posts, titles and order
 */
const loadBlog = async (store) => {
  const titles = await loadFolderFrontmatter('title', store.site, store.language, 'blog')
  const order = await loadFolderFrontmatter('date', store.site, store.language, 'blog', formatDate)
  const authors = await loadFolderFrontmatter('author', store.site, store.language, 'blog')
  const images = await loadFolderFrontmatter('image', store.site, store.language, 'blog')

  // Merge titles, order, author, and image info
  const merged = {}
  for (const slug in titles)
    merged[slug] = {
      t: titles[slug],
      o: order[slug],
      s: slug,
      a: authors[slug],
      i: images[slug],
    }
  // Order based on post data (descending)
  const ordered = orderBy(merged, 'o', 'desc')

  // Structure as posts and meta objects
  const posts = {}
  const meta = {}
  for (const post of ordered) {
    posts[post.s] = { t: post.t }
    meta[post.s] = { a: post.a, d: post.o, i: post.i }
  }

  return { posts, meta }
}

/*
 * Loads all showcase posts, titles and order
 */
const loadShowcase = async (store) => {
  const titles = await loadFolderFrontmatter('title', store.site, store.language, 'showcase')
  const order = await loadFolderFrontmatter(
    'date',
    store.site,
    store.language,
    'showcase',
    formatDate
  )
  const makers = await loadFolderFrontmatter('maker', store.site, store.language, 'showcase')
  const images = await loadFolderFrontmatter('image', store.site, store.language, 'showcase')

  // Merge titles, order, maker, and image info
  const merged = {}
  for (const slug in titles)
    merged[slug] = {
      t: titles[slug],
      o: order[slug],
      s: slug,
      m: makers[slug],
      i: images[slug],
    }
  // Order based on post data (descending)
  const ordered = orderBy(merged, 'o', 'desc')

  // Structure as posts and meta objects
  const posts = {}
  const meta = {}
  for (const post of ordered) {
    posts[post.s] = { t: post.t }
    meta[post.s] = { m: post.m, d: post.o, i: post.i }
  }

  return { posts, meta }
}

/*
 * Loads all newsletter posts, titles and order
 */
const loadNewsletter = async (store) => {
  const titles = await loadFolderFrontmatter('title', store.site, store.language, 'newsletter')
  const order = await loadFolderFrontmatter('edition', store.site, store.language, 'newsletter')

  return mergeOrder(titles, order)
}

/*
 * Write out prebuild files
 */
const writeFiles = async (type, site, pages) => {
  fs.writeFileSync(
    path.resolve('..', site, 'prebuild', `${type}.mjs`),
    `${header}export const pages = ${JSON.stringify(pages)}`
  )
}

/*
 * Write out a single prebuild file
 */
const writeFile = async (filename, exportname, site, content) => {
  fs.writeFileSync(
    path.resolve('..', site, 'prebuild', `${filename}.mjs`),
    `${header}export const ${exportname} = ${JSON.stringify(content)}`
  )
}

/*
 * Main method that does what needs doing for the docs
 */
export const prebuildDocs = async (store) => {
  store.docs = await loadDocs(store)
  await writeFiles('docs', store.site, store.docs)
}

/*
 * Main method that does what needs doing for the blog/showcase/newsletter posts
 */
export const prebuildPosts = async (store) => {
  store.posts = {
    blog: await loadBlog(store),
    showcase: await loadShowcase(store),
    newsletter: { posts: await loadNewsletter(store) },
  }
  await writeFiles('blog', 'org', store.posts.blog.posts)
  await writeFiles('showcase', 'org', store.posts.showcase.posts)
  await writeFiles('newsletter', 'org', store.posts.newsletter)
  await writeFile('blog-meta', 'meta', 'org', store.posts.blog.meta)
  await writeFile('showcase-meta', 'meta', 'org', store.posts.showcase.meta)
}
